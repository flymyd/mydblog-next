[
  {
    "name": "Electron Vite React初始化搭建.md",
    "updateTime": "2023-04-12T09:20:06.358Z",
    "title": "Electron Vite React初始化搭建",
    "id": 0,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "",
    "abstract": "新建electron文件夹...",
    "heads": [
      "用Vite初始化工程",
      "安装electron及HMR相关包",
      "electron相关入口点及配置",
      "新建electron文件夹",
      "main.js",
      "preload.js",
      "修改vite.config.ts",
      "修改package.json",
      "添加属性main、build，修改scripts"
    ]
  },
  {
    "name": "HbuilderX格式化scss、less文件.md",
    "updateTime": "2023-04-12T09:20:06.352Z",
    "title": "HbuilderX格式化scss、less文件",
    "id": 1,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "",
    "abstract": "HbuilderX自带了jsbeautify插件以进行代码格式化。然而当我们尝试新建外部CSS文件以分割过长组件代码时会发现，以scss或less为后缀的样式表文件无法正确地被格式化。解决该问题的方法...",
    "heads": [
      "HbuilderX自带了jsbeautify插件以进行代码格式化。然而当我们尝试新建外部CSS文件以分割过长组件代码时会发现，以scss或less为后缀的样式表文件无法正确地被格式化。解决该问题的方法有两种：",
      "一、在DCloud插件市场下载Prettier插件",
      "二、手动修改HbuilderX相关配置，使用自带的jsbeautify进行格式化",
      "由于HbuilderX可能会存在更新覆盖相关配置的可能性，所以这里编写node脚本进行批量修改。版本更新后若失效，重新执行即可。以Mac开发环境为例，Windows用户可自行修改路径设置。",
      "使用方式：",
      "enableCssFormater.js代码："
    ]
  },
  {
    "name": "JavaScript查漏补缺 - 1.md",
    "updateTime": "2023-04-12T09:24:04.270Z",
    "title": "JavaScript查漏补缺 - 1",
    "id": 2,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "",
    "abstract": "...",
    "heads": [
      "安全地将字符串转换为数组"
    ]
  },
  {
    "name": "Nest.js基础搭建 && Mysql单表CRUD.md",
    "updateTime": "2023-04-12T09:24:04.315Z",
    "title": "Nest.js基础搭建 && Mysql单表CRUD",
    "id": 3,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "",
    "abstract": "src/config/Database.ts...",
    "heads": [
      "安装相关依赖",
      "配置数据源",
      "src/config/Database.ts",
      "src/app.module.ts",
      "新建CRUD模块",
      "TypeORM中对于Entity的定义",
      "src/user/entities/user.entity.ts",
      "src/user/user.module.ts",
      "src/user/dto/create-user.dto.ts",
      "src/user/user.service.ts",
      "用Postman测试一下，成功！"
    ]
  },
  {
    "name": "Next.js文档 - 1.页面.md",
    "updateTime": "2023-03-01T09:36:46.095Z",
    "title": "Next.js文档 - 1.页面",
    "id": 4,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "local",
    "abstract": "Next.js 13 采用了beta版的目录结构（/app）。新结构默认支持layouts（布局）、嵌套路由、服务器端渲染组件。与此同时你可以在layout中获取整个应用的数据，包括支持更精细粒度的嵌...",
    "heads": [
      "title: Next.js文档\ndate: 2023-3-1 17:36:44",
      "页面（Pages）",
      "Next.js 13 采用了beta版的目录结构（/app）。新结构默认支持layouts（布局）、嵌套路由、服务器端渲染组件。与此同时你可以在layout中获取整个应用的数据，包括支持更精细粒度的嵌套布局。",
      "在Next中，page是从pages文件夹下的js、jsx、ts、tsx文件中导出的React组件。每个页面都根据其文件名与路由相关联。",
      "例：这是一个对应/about路由的组件pages/about.js",
      "动态路由页面",
      "Next支持动态路由。比如你创建了一个名为pages/posts/[id].js的文件，那么你可以通过形如 posts/1、posts/2的路由来访问它。",
      "预渲染",
      "默认情况下，Next会对每个页面进行预渲染，这意味着Next是提前为每个页面生成HTML，而不是由客户端的js来完成所有工作的。预渲染可以带来更好的性能和 SEO。",
      "每个生成的 HTML 都与该页面所需的最简 JavaScript 代码相关联。当浏览器加载页面时，其 JavaScript 代码会运行并使页面可交互。（这个过程称为水合）",
      "PS：在阅读下一节后更有助于理解水合的概念。",
      "预渲染的两种形式",
      "Next有两种预渲染方式：静态生成（SSG, Static Server Generation）和服务器端渲染（SSR, Server Side Rendering），区别在于它何时为页面生成HTML。",
      "Next允许你决定用于每个页面的预渲染形式。比如，你可以选择对大多数页面使用静态生成，而对特定页面使用SSR的方式来创建“混合”的Next.js 应用。",
      "出于性能原因考虑，建议尽量使用SSG。静态生成的页面可以由 CDN 缓存，无需额外配置即可提高性能。但是，在某些情况下，SSR可能是唯一的选择。",
      "PS：比如说你要构建一个响应式页面，这里面有一个导航栏需要在移动端和PC端上有不同的表现形式。由于需要访问window对象，你无法生成一个纯静态的页面。这时就需要SSR进行脱水生成。",
      "您还可以将客户端数据获取与SSG或SSR一起使用。这意味着页面的某些部分可以完全由客户端JavaScript呈现。",
      "静态生成（SSG）",
      "如果一个页面使用了SSG，这个页面的HTML将会在build时生成。这意味着在生产环境下该页面的HTML在你启动应用服务的时候就已经被生成好了。这个HTML会在每个请求中被复用，它可以被CDN缓存。",
      "在Next中你既可以静态生成有（外部）数据的页面，也可以生成一个纯粹的简单页面。",
      "无外部数据的静态生成",
      "默认情况下，Next将会预渲染一个无外部数据的页面。例如：",
      "此页面不需要获取任何用于预渲染的外部数据。在这种情况下，Next 在build时会生成一个单独的 HTML 文件。",
      "有外部数据的静态生成",
      "有的页面需要在预渲染时请求额外的数据，这通常有两种场景，并且可能同时出现：",
      "场景一：页面内容依赖于外部数据",
      "博客页面可能需要从 CMS（内容管理系统）获取博客文章列表。",
      "为了在预渲染时获取此数据，Next 允许你通过在该文件里调用export async getStaticProps()函数。此函数在构建时被调用，并允许您将获取的数据通过props传递给将被预渲染的页面。",
      "场景二：页面路径依赖于外部数据",
      "Next允许你创建动态路由页面。比如，你可以创建一个名为pages/posts/[id].js的文件来展示基于id的blog页。当你访问posts/1的时候，[id].js页将会展示id为1的博文。",
      "但是，有时候这个id是依赖于外部数据的。比如说你的数据库里目前只有id为1的博文。这时候你在构建时只会预渲染post/1。但过后你可能添加了id为2、3、4...的博文。这时，你想要预渲染所有已经被添加到数据库里的博文。",
      "所以你预渲染的页面路径依赖于外部数据。为了处理这个问题，Next允许您从动态路由页面调用export async getStaticPaths()函数。此函数在构建时被调用，并允许您指定要预渲染的路径。例如原本的pages/posts/[id].js形如：",
      "根据上述改造后：",
      "我什么时候应该使用SSG？",
      "我们建议尽可能使用SSG，因为您的页面可以只构建一次并由 CDN 提供服务，这比让服务器在每次请求时呈现页面要快得多**。**",
      "您可以为多种类型的页面使用SSG，包括：",
      "您应该问问自己：“我可以在用户请求之前预呈现此页面吗？” 如果答案是肯定的，那么您应该选择SSG。",
      "另一方面，如果您不能在用户请求之前预呈现页面，那么静态生成不是一个好主意**。**也许您的页面显示经常更新的数据，并且页面内容会在每次请求时发生变化。",
      "在这种情况下，您可以执行以下操作之一：",
      "服务器渲染（SSR）",
      "如果页面使用SSR，则每次请求时都会生成页面 HTML 。",
      "要为页面使用SSR，您需要在该页面中调用export async getServerSideProps(). 服务器将在每次请求时调用此函数。",
      "例如，假设您的页面需要预渲染经常更新的数据（从外部 API 获取），您可以在getServerSideProps中获取数据并将其通过props传递给页面，如下所示：",
      "getServerSideProps使用方法很像getStaticProps， 但getServerSideProps会在每个请求时被执行，而非仅在build时执行一次。",
      "总结",
      "我们已经讨论了 Next.js 的两种预渲染形式。",
      "下面是文档之外的理解部分："
    ]
  },
  {
    "name": "Next.js文档 - 2.数据获取-SSR.md",
    "updateTime": "2023-04-12T09:24:04.301Z",
    "title": "Next.js文档 - 2.数据获取-SSR",
    "id": 5,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "local",
    "abstract": "当你在一个Page中导出了getServerSideProps函数，那么Next将会在每次页面请求前使用getServerSideProps返回的数据进行预渲染。",
    "heads": [
      "getServerSideProps（SSR使用）",
      "当你在一个Page中导出了getServerSideProps函数，那么Next将会在每次页面请求前使用getServerSideProps返回的数据进行预渲染。",
      "请注意，无论渲染类型是什么，任何props都将被传递到页面组件上，并可以在客户端得到的初始HTML中被查看，这是为了让页面能够被正确地水合。请确保你没有将任何不应在客户端上出现的敏感信息传递给props。",
      "getServerSideProps何时运行",
      "getServerSideProps仅在服务器端运行，从不在浏览器上运行。如果页面使用getServerSideProps，则：",
      "当你直接请求此页面时，getServerSideProps在请求时运行，并且此页面将使用返回的 props 进行预渲染",
      "当你从客户端侧请求一个从next/link或next/router转变而来的页面时，Next会执行getServerSideProps，向服务器发送一个API请求。",
      "When you request this page on client-side page transitions through next/link or next/router, Next.js sends an API request to the server, which runs getServerSideProps",
      "getServerSideProps返回用于渲染页面的 JSON。所有这些工作都将由Next自动处理，所以只要你已经声明好了getServerSideProps，那就不需要做任何额外的事情。",
      "您可以使用next-code-elimination来验证 Next.js 从客户端侧产物中删除了什么。",
      "getServerSideProps只能从**Page组件（页面文件）**导出。您不能从非页面文件中导出它。",
      "请注意，您必须导出getServerSideProps为独立函数——如果您将其添加为页面组件的属性，它将无法工作。",
      "何时应该使用getServerSideProps",
      "getServerSideProps仅当您需要渲染必须在每次请求时预先获取数据的页面时才应使用。这可能是由于请求的数据或属性（如authorization标头或地理位置）决定的。使用getServerSideProps的页面将在请求时在服务器端渲染，并且只有在配置了缓存控制标头时才会被缓存。",
      "如果您不需要在请求页面期间渲染数据，那么您应该考虑在客户端请求数据或使用getStaticProps.",
      "getServerSideProps 或 API 路由",
      "当您想从服务器获取数据时，可能很想去访问API 路由，然后从getServerSideProps调用该 API 路由的逻辑。这是一种不必要且低效的方法，因为它会由于调用getServerSideProps以及访问服务器上运行的 API 路由而导致发出额外的请求。",
      "以下面的例子为例。API 路由用于从 CMS 获取一些数据。然后直接从getServerSideProps调用该 API 路由。这会产生额外的调用，从而降低性能。相反，应该直接将 API 路由中使用的逻辑导入到getServerSideProps。这意味着直接从getServerSideProps内部调用 CMS、数据库或其他 API 。",
      "getServerSideProps与边缘路由",
      "getServerSideProps可以同时与Serverless 和 Edge Runtimes结合使用，你可以在两者中设置 props。但是，目前在 Edge Runtime 中，您无权访问响应对象。这意味着您不能——例如——在getServerSideProps中添加cookie。要访问响应对象，您应该继续使用Node.js 运行时（即默认运行时）。",
      "你可以为通过自定义config来为每个Page显式地设置运行时，例如：",
      "在客户端侧获取数据（CSR）",
      "如果你的页面包含频繁更新的数据，并且你不需要预渲染数据，你可以在客户端获取数据。这方面的一个例子是用户特定的数据：",
      "例如，此方法适用于用户仪表板页面。由于仪表板是私有的、特定于用户的页面，因此与 SEO 无关，并且不需要预渲染该页面。数据更新频繁，需要请求时再获取数据。",
      "使用 getServerSideProps 在请求时获取数据",
      "以下示例显示了如何在请求时获取数据并预渲染结果。",
      "使用服务端渲染（SSR）进行缓存",
      "你可以在getServerSideProps内部使用缓存标头(Cache-Control)来缓存动态响应，如：使用stale-while-revalidate",
      "getServerSideProps是否会渲染错误页（500）",
      "如果getServerSideProps内部抛出错误，它将显示pages/500.js文件。查看500 页的文档以了解有关如何创建它的更多信息。在开发环境下不会使用此文件，而是会显示dev遮罩层。"
    ]
  },
  {
    "name": "Next.js文档 - 3.数据获取-SSG.md",
    "updateTime": "2023-04-12T09:24:04.279Z",
    "title": "Next.js文档 - 3.数据获取-SSG",
    "id": 6,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "local",
    "abstract": "当你在一个Page中导出了getStaticProps 函数，那么Next将会在构建时使用getStaticProps返回的数据预生成这个页面。",
    "heads": [
      "getStaticProps（SSG使用）",
      "当你在一个Page中导出了getStaticProps 函数，那么Next将会在构建时使用getStaticProps返回的数据预生成这个页面。",
      "请注意，无论渲染类型是什么，任何props都将被传递到页面组件上，并可以在客户端得到的初始HTML中被查看，这是为了让页面能够被正确地水合。请确保你没有将任何不应在客户端上出现的敏感信息传递给props。",
      "PS：SSG页面的生命为：声明getStaticProps => Next构建（build） => 用户请求该页面（可被复用）",
      "何时应该使用getStaticProps",
      "如果出现以下情况，您应该使用getStaticProps：",
      "getStaticProps何时运行",
      "getStaticProps始终在服务器上运行，从不在客户端上运行。您可以使用此工具验证getStaticProps内部编写的代码是否已从客户端包中删除。",
      "当与增量静态再生（ISG）结合使用时，getStaticProps将在后台运行，同时重新验证陈旧页面，并将新页面提供给浏览器。",
      "getStaticProps无法访问传入请求（例如查询参数或 HTTP 标头），因为它会生成静态 HTML。如果您需要访问您页面的请求，请考虑在getStaticProps之外结合使用Middleware",
      "使用 getStaticProps 从 CMS 获取数据",
      "这是一个从 CMS 获取博客文章列表的例子：",
      "直接写服务端代码",
      "由于getStaticProps只在服务器端运行，它永远不会在客户端运行。它甚至不会包含在浏览器的 JS 包中，因此您可以编写直接的数据库查询，而无需将它们发送到浏览器。",
      "这意味着你可以直接在getStaticProps里写服务端代码以代替在getStaticProps中访问API路由来获取数据的行为。",
      "如下所示，这里有一个用于从CMS获取一些数据的API路由。这个API路由直接在getStaticProps中被调用，这产生了额外的开销，降低了性能。应该取而代之的是，把从CMS获取数据的逻辑放在lib/文件夹下共享。这段逻辑可以同时共享给getStaticProps。",
      "如果你不使用API路由来获取数据，那么也可以直接使用fetch()API在getStaticProps里获取数据。",
      "静态生成HTML和JSON",
      "当一个使用了getStaticProps的页面在构建时被预渲染，除了页面 HTML 文件之外，Next.js 还会生成一个 JSON 文件来保存getStaticProps运行的结果。",
      "此 JSON 文件将用于通过next/link或next/router访问的客户端路由。当您导航到使用getStaticProps预渲染的页面时，Next.js 会获取此 JSON 文件（在构建时预生成）并将其用作页面组件的props。这意味着客户端侧页面转换时不会调用getStaticProps，因为该页面仅使用导出的 JSON。",
      "使用增量静态生成（ISR）时，getStaticProps将在后台执行以生成客户端导航所需的 JSON。您可能会以针对同一页面发出多个请求的形式看到这一点，但是，这是有意为之的，不会影响最终的性能。",
      "何处可以使用getStaticProps",
      "getStaticProps只能在页面组件里被导出。你不能从一个非页面文件或_app、_document、_error等页面导出该函数。",
      "这种限制的原因之一是 React 需要在页面渲染之前拥有所有必需的数据。",
      "此外，您必须将export getStaticProps作为独立函数使用——如果您将其添加为页面组件的属性，它将无法工作。",
      "注意：如果您已经创建了自定义app，请确保将pageProps传递给链接文档中所示的页面组件，否则props将为空。",
      "开发模式下每次请求都会执行",
      "在开发模式下(next dev)，每个请求都会调用getStaticProps",
      "预览模式",
      "您可以使用预览模式暂时绕过SSG并在请求时渲染页面而不是构建时。例如，您可能正在使用无头 CMS 并希望在发布之前预览草稿。"
    ]
  },
  {
    "name": "React学习心得.md",
    "updateTime": "2023-04-12T09:24:04.247Z",
    "title": "React学习心得",
    "id": 7,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "",
    "abstract": "jsx的声明很简单，形如：",
    "heads": [
      "一、JSX",
      "jsx的声明很简单，形如：",
      "在jsx中，React组件的标签名必须要大写，而DOM标签名必须小写。",
      "jsx中的表达式模板为{}而非{{}}",
      "jsx中只能使用表达式，而不能用多行JS语句。这一点类似于vue中模板、属性等动态赋值时的写法",
      "部分标签属性名称有变化，如class => className，onclick => onClick",
      "jsx中的注释为{/**/}，例如：",
      "jsx在react中实质上只是React.createElement的语法糖。",
      "二、组件",
      "声明一个简单的React组件，render函数返回的jsx其实就相当于Vue中的template，有且只能有一个根节点",
      "给上述组件设置两个Props：title和subtitle",
      "有状态组件：需要用到state保存变化；state其实就类似于Vue中的data（this.state.foo = data{ foo }）。",
      "简单的计数器组件（有状态）：",
      "自定义组件的构造器中首先要调用super(props)，这一步是为了调用React.Component的构造器。",
      "无状态组件的函数式声明",
      "Props的类型校验",
      "这类似于Vue中的Props类型校验。但在React中除了基本类型外还多了Element和Node属性。",
      "当需要判断object和array内部数据类型的时候，可以如下操作：",
      "这有点像TypeScript中对于类型的声明。",
      "如果该Props是必传的，那要在类型属性上调用isRequired，例：",
      "如果需要为Props指定默认值，则可以使用defaultProps实现：",
      "内联样式的使用",
      "style后的双花括号实际上的含义是：一个JS表达式中包括一个对象。",
      "也可以把上面的代码改写一下，将样式类抽取出来单独声明：",
      "这类似于Vue中的",
      "引入外部CSS：",
      "import '../assets/css/common.css'",
      "组件的生命周期",
      "挂载阶段：",
      "constructor（调用React.Component的构造器，进行state的初始化及绑定事件处理方法等工作）",
      "componentWillMount（类似beforeMounted，在这里调用this.setState不会引起组件的重新渲染）",
      "render：根据props和state返回一个React Element。在这里不能调用this.setState，否则会改变组件的状态",
      "componentDidMount：组件挂载到DOM后调用。此时已经可以获取到DOM，类似于Mounted。在这里调用this.setState也会引起组件的重新渲染。",
      "componentWillReceiveProps(newProps)：父组件传给该组件新的props时触发的钩子，一般需要比较新props与this.props来决定是否执行props变化后的逻辑，例如根据新props调用this.setState触发重新渲染。",
      "shouldComponentUpdate(newProps, newState)：该方法决定组件是否继续更新。一般通过比较新props、state与组件当前的props、state来决定该方法返回true还是false，从而减少组件不必要的渲染，优化性能。",
      "componentWillUpdate(newProps, newState)：该方法在render调用前执行。",
      "componentDidUpdate(oldProps, oldState)：组件更新后的钩子，可以在此处操作更新后的DOM",
      "componentWillUnmount：卸载组件前调用，类似于beforeDestory。",
      "循环的使用",
      "在Vue中循环渲染一个组件，类似下例：",
      "而在React中，可以如下操作：",
      "或者使用自运行函数，去执行其他的操作，例如for：",
      "for也可以通过预先转换数组的形式往页面里回写："
    ]
  },
  {
    "name": "uniapp-仿微信相机.md",
    "updateTime": "2023-04-12T09:24:04.265Z",
    "title": "uniapp-仿微信相机",
    "id": 8,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "local",
    "abstract": "在微信小程序中直接使用uni.chooseMedia即可调用微信相机进行摄录。但为了保持体验的相似性，造一个仿微信相机的轮子是有必要的...",
    "heads": [
      "在微信小程序中直接使用uni.chooseMedia即可调用微信相机进行摄录。但为了保持体验的相似性，造一个仿微信相机的轮子是有必要的",
      "因为小程序的胶囊很碍事，所以对UI进行了调整，功能按钮均移动到页面下方。",
      "本相机支持照片及视频的摄录，拍摄后可进行预览、重拍。采用页面栈的形式进行传值。",
      "使用例：ClockIn.vue（记得先在pages.json中注册）",
      "源代码：TakePhotoAndVideo.vue"
    ]
  },
  {
    "name": "uniapp-微信小程序实现全局事件监听.md",
    "updateTime": "2023-04-12T09:24:04.274Z",
    "title": "uniapp-微信小程序实现全局事件监听",
    "id": 9,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "local",
    "abstract": "最近接到需求，领导希望使用微信开放平台上免费的We分析进行数据埋点，但又不希望在现有uniapp开发的微信小程序代码上做侵入式修改，笔者奉命进行了技术调研，考虑通过劫持事件的方式来实现捕获特定事件并上...",
    "heads": [
      "零、前言",
      "最近接到需求，领导希望使用微信开放平台上免费的We分析进行数据埋点，但又不希望在现有uniapp开发的微信小程序代码上做侵入式修改，笔者奉命进行了技术调研，考虑通过劫持事件的方式来实现捕获特定事件并上传分析平台的功能。",
      "需要特别注意的是，微信小程序是不能得到document对象的，$el上挂载的也是undefined，自然也就不能通过全局addEventListener的方式来监听特定事件。在调研中想到可以通过劫持小程序的自定义组件构造器Component()来实现事件的监听。",
      "为了便于理解，部分数据结构通过TypeScript接口形式进行描述。",
      "一、软件环境",
      "二、相关分析及实现",
      "uniapp编译微信小程序时对于事件的处理分析",
      "部分知识via掘金：https://juejin.cn/post/6968438754180595742#heading-20",
      "uniapp使用了uni-app runtime这个运行时将小程序发行代码进行打包，实现了Vue与小程序之间的数据及事件同步。",
      "源Vue模板及编译产物wxml对照",
      "uniapp的模板编译器代码在/Applications/HBuilderX.app/Contents/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/uni-template-complier下。",
      "首先以一个简单的Vue模板为例，观察uniapp是如何将Vue template编译为wxml的：",
      "编译结果为：",
      "可以看到，uniapp将tap和touchstart事件绑定到__e函数上，然后将事件对应的动作放到了名为eventOpts的dataset中。",
      "data-event-opts",
      "data-event-opts非常重要。data-event-opts是一个二维数组，每个子数组代表一个事件类型。事件类型有两个值，第一个表示事件类型名称，第二个表示触发事件函数的个数。事件函数又是一个数组，第一个值表述事件函数名称，第二个是参数表。下面用TypeScript的类型声明方式进行简单描述：",
      "对照模板，就可以得出如下推论：",
      "['tap',[['add'],['subtract',[2]]]]表示事件类型为tap，触发函数有两个，一个为add函数且无参数，一个为subtract且参数为2。 ['touchstart',[['mixin',['$event']]]]表示事件类型为touchstart，触发函数有一个为mixin，参数为$event对象。",
      "不难看出，我们在进行事件捕捉时，只需要读取到data-event-opts[i][0]就可以得到每个事件的类型。",
      "handleEvent事件：__e",
      "所有的事件都会调用__e事件，也就是handleEvent。在上文的模板中，handleEvent做了如下操作：",
      "1、拿到点击元素上的data-event-opts属性:[['tap',[['add'],['subtract',[2]]]],['touchstart',[['mixin',['$event']]]]]",
      "2、根据点击类型获取相应数组，比如bindTap就取['tap',[['add'],['subtract',[2]]]]，bindtouchstart就取['touchstart',[['mixin',['$event']]]]",
      "3、依次调用相应事件类型的函数，并传入参数，比如tap调用this.add();this.subtract(2)",
      "uniapp对mp-wx的相关处理在/Applications/HBuilderX.app/Contents/HBuilderX/plugins/uniapp-cli/node_modules/@dcloudio/uni-mp-weixin下。",
      "微信小程序自定义组件Component",
      "mp-wx中的Component文档：https://developers.weixin.qq.com/miniprogram/dev/reference/api/Component.html",
      "构造器Component()",
      "在uniapp-mp-wx中，组件的装载是通过实例化Component进行的。uniapp会默认装载如下8个参数：",
      "并且在methods中注入如下两个函数：",
      "劫持自定义组件构造器Component",
      "劫持Component的构造器，在每个组件的__e中注入自定义的事件劫持器eventProxy",
      "通过劫持事件处理器__e，我们可以实现触发事件时执行我们想要的逻辑了。",
      "分析事件对象并编写事件处理器劫持函数eventProxy",
      "微信小程序事件对象描述文档：https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html#%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1",
      "在上一步里我们劫持了Component，并且成功获得了事件处理器__e，那么编写针对事件处理器的劫持函数吧。",
      "uniapp-mp-wx中，事件对象通常具有如下属性：",
      "其中，对于数据埋点尤其有用的是如下四个属性：",
      "type：描述事件类型。常见种类有tap（click）、input、blur、focus等",
      "currentTarget：事件绑定的当前组件",
      "从Vue模板编译一节中可知，我们应该关注currentTarget.dataset.eventOpts这个属性，这里记载了事件被触发时的一些信息。",
      "mark：可以使用 mark 来识别具体触发事件的 target 节点。此外， mark 还可以用于承载一些自定义数据（类似于 dataset ）。",
      "当事件触发时，事件冒泡路径上所有的 mark 会被合并，并返回给事件回调函数。（即使事件不是冒泡事件，也会 mark 。）",
      "如果想要得到一些详细的锚点数据，可以在代码中做一些mark标记。",
      "detail：自定义事件所携带的数据，如表单组件的提交事件会携带用户的输入，媒体的错误事件会携带错误信息，详见组件定义中各个事件的定义。",
      "点击事件的detail 带有的 x, y 同 pageX, pageY 代表距离文档左上角的距离。",
      "这里给出tap及input事件返回的detail结构：",
      "结合如上属性，简单地完善一下事件劫持器吧：",
      "三、完整代码结构",
      "使用：在项目的main.js里引入即可",
      "四、后记",
      "上述事件劫持器只是一个例子，实现了基本的tap事件记录。实际上笔者通过扩展配置读取的方式来完成更加便捷的埋点操作，后续只需产品给出希望收集的事件名，开发在固定的配置文件中写好代码中事件触发的函数名即可实现tap白名单记录功能。更加详细的埋点功能可以通过阅读分析事件对象小节来扩展，在此仅做抛砖引玉。"
    ]
  },
  {
    "name": "uniapp-阿里云OSS直传封装.md",
    "updateTime": "2023-04-12T09:24:04.283Z",
    "title": "uniapp-阿里云OSS直传封装",
    "id": 10,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "local",
    "abstract": "本文使用的方式是直接上传，不需要向后端获取凭据。优点是上传方便，缺点是本地存储Key较为不安全。",
    "heads": [
      "本文使用的方式是直接上传，不需要向后端获取凭据。优点是上传方便，缺点是本地存储Key较为不安全。",
      "一、目录结构",
      "二、使用例",
      "三、代码",
      "oss/OSSConfig.js",
      "oss/index.js",
      "crypto/base64.js",
      "crypto/crypto.js",
      "crypto/hmac.js",
      "crypto/sha1.js"
    ]
  },
  {
    "name": "Vue3项目初始化搭建.md",
    "updateTime": "2023-04-12T09:24:04.260Z",
    "title": "Vue3项目初始化搭建",
    "id": 11,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "",
    "abstract": "俗话说的好，万事开头难。这篇文章主要介绍一下Nuxt 3项目的初始化所需工作。",
    "heads": [
      "前言",
      "俗话说的好，万事开头难。这篇文章主要介绍一下Nuxt 3项目的初始化所需工作。",
      "主要配置",
      "技术选型：",
      "开始吧",
      "1、使用Vite构建项目并安装插件",
      "配置基本的vite.config.ts",
      "配置tsconfig.json",
      "安装node类型声明及配置TSX",
      "修改vite.config.ts",
      "安装插件vite-plugin-vue-setup-extend（在setup标签上声明name）",
      "修改vite.config.ts",
      "安装插件unplugin-auto-import（无需import即可使用Vue的API）",
      "修改vite.config.ts",
      "2、配置Vue Router",
      "新建/src/router/index.ts",
      "修改main.ts",
      "3、配置Pinia",
      "修改main.ts",
      "新建/src/store/index.ts",
      "4、安装Sass、PostCSS及一些插件",
      "vite.config.ts添加节点",
      "配置iconify",
      "修改vite.config.ts",
      "修改main.ts",
      "封装方便的组件",
      "在模板中使用",
      "配置UnoCSS",
      "修改vite.config.ts",
      "修改main.ts"
    ]
  },
  {
    "name": "从Vue2到Vue3.md",
    "updateTime": "2023-04-12T09:24:04.306Z",
    "title": "从Vue2到Vue3",
    "id": 12,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "",
    "abstract": "在下文中，Vue 2.x将会简称为v2。如无特别说明，Vue或v3特指Vue 3.x。",
    "heads": [
      "前言",
      "在下文中，Vue 2.x将会简称为v2。如无特别说明，Vue或v3特指Vue 3.x。",
      "常用全局API",
      "Vue.prototype",
      "在v2中，我们经常使用形如Vue.prototype.$xxx = xxx的全局挂载形式以添加所有组件都能访问的 property。但在v3中，该api迁移为app.config.globalProperties.$xxx = xxx。",
      "Vue.directive",
      "v3中迁移为app.directive",
      "Vue.extend",
      "移除。",
      "Vue.mixin",
      "迁移为app.mixin。然而，v3中更建议使用hooks来代替mixins。",
      "其它：参阅全局API应用实例",
      "全局API摇树",
      "v3中为了减少打包体积，被暴露在Vue对象上的全局API将会在显式导入后才被打包。如：",
      "模板和常用指令",
      "模板",
      "Vue3单文件组件不再仅支持一个根节点。换言之，你可以创建若干个根节点，如：",
      "当一个模板包含多个根节点时，这个模板则在AST时被表示为一个Fragment。但是，如果该组件作为一个子组件出现，而该组件下又有若干个子组件，那么需要显示定义attribute绑定的位置。此处请参阅多根节点的 Attributes 继承。如果无法很好地了解$attrs所代表的意义，那么请使用传统单根节点写法，这有助于减轻心智负担。",
      "v-model（对于自定义组件的破坏性更改）",
      "在v2中，v-model拥有一组默认的prop及事件默认名称——通常我们称为v-bind及v-on的语法糖。复习一下：",
      "但在v3中，用于自定义组件时：",
      "v-model的prop和事件的默认名称已经更改：",
      "prop: value -> modelValue",
      "事件： input -> update:modelValue",
      "子组件的model选项及.sync修饰符也已被移除。",
      "现在可以在同一个组件上使用多个 v-model 绑定；",
      "现在可以自定义 v-model 修饰符。",
      "更详细的说明，参考：v-model",
      "key",
      "v-if和v-for的优先级（相反）",
      "两者作用于同一个元素上时，v-if 会拥有比 v-for 更高的优先级。相对地，v2中 v-for 会优先作用。",
      "v-bind合并",
      "v-bind 的绑定顺序会影响渲染结果。简而言之，v3中的属性覆盖规则类似于css，后来者居上。如：",
      "重要：移除v-on.native修饰符",
      "v2中默认情况下，传递给带有 v-on 的组件的事件监听器只能通过 this.$emit 触发。要将原生 DOM 监听器添加到子组件的根元素中，可以使用 .native 修饰符：",
      "v3中则移除了.native修饰符。同时，新增的 emits 选项允许子组件定义真正会被触发的事件。因此，对于子组件中未被定义为组件触发的所有事件监听器，Vue 现在将把它们作为原生事件监听器添加到子组件的根元素中 (除非在子组件的选项中设置了 inheritAttrs: false)。",
      "事件API（EventBus）",
      "$on，$off 和 $once 实例方法已被移除，组件实例不再实现事件触发接口。因此，忘掉事件总线吧。更多请参阅事件 API",
      "其它被移除的常见API或属性",
      "filter（过滤器）",
      "this.$children",
      "异步组件",
      "请参阅异步组件",
      "新增emits选项",
      "Vue 3 现在提供一个 emits 选项，和现有的 props 选项类似。这个选项可以用来定义一个组件可以向其父组件触发的事件。更多请参阅emits选项",
      "Watch一个数组",
      "当侦听一个数组时，只有当数组被替换时才会触发回调。如果你需要在数组被改变时触发回调，必须指定 deep 选项。",
      "一些小变化",
      "自定义指令",
      "Data选项",
      "组件选项 data 的声明不再接收纯 JavaScript object，而是接收一个 function。也就是说，现在只接受形如data() { return { foo: 'bar' } }的数据了。",
      "当合并来自 mixin 或 extend 的多个 data 返回值时，合并操作现在是浅层次的而非深层次的 (只合并根级属性)。",
      "Transition相关",
      "重要：组合式API——快速入门",
      "这里是一组简单的示例，uniapp中将<div>换为<view>、<span>换为<text>等即可：",
      "父组件Home.vue",
      "子组件ZoTest.vue",
      "为了加速学习，这里直接使用了script setup语法糖。用法很简单，template部分写法和v2一样，script部分从以前的：",
      "方式初始化变为：",
      "当使用setup写法时，任何在 <script setup> 声明的顶层的绑定 (包括变量，函数声明，以及 import 导入的内容) 都能在模板中直接使用。import 导入的内容也会以同样的方式暴露。这意味着我们可以在模板表达式中直接使用导入的 helper 函数，而不需要通过 methods 选项来暴露它。",
      "如上述代码中的helloText是一个非响应式常量，而helloText是一个响应式数据。它们在模板中都可以被直接访问。",
      "响应式数据（也就是v2中的data(){ return {} }）需要明确地使用响应式API创建。常用的响应式有ref()和reactive()。",
      "ref()常用于基础数据类型的响应式声明，如number、string等。而reactive则用于声明响应式对象，比如Object或Array。",
      "在v3中，响应式对象的追踪原理从基于Object.defineProperty() + getters/setters变成了Proxy，这意味着像数组之类的JavaScript对象也能被直接监听修改了。响应式转换是“深层”的：它会影响到所有嵌套的属性。一个响应式对象也将深层地解包任何ref属性，同时保持响应性。",
      "ref在模板中访问时会被自动解包。可以在上述代码看到，const helloText = ref('Hello world!')被直接读取了。然而，当在script中尝试访问或修改由ref创建的响应式变量时，则需要访问ref.value，如上述代码中的helloText.value = '我被点击了'; ",
      "由reactive创建的响应式对象则只需要直接访问。如eventRecorder.count +=1或testArray.push(123);等。",
      "ref()与reactive()均会根据初始值进行类型推导。若要声明其它可能的类型，则需要在泛型中传入类型，如：",
      "响应式对象若直接解构则会丢失响应性。比如const {count} = eventRecorder后再count++则不会被追踪。这时应该使用toRefs()进行响应式转换。监听props时也同样建议先进行响应式解构再watch。这里是一个将reactvice安全解构的例子：",
      "与v2不同的是，v3的props与emit需要用define宏声明类型，使用时使用define的返回值进行访问。声明props的各种属性则需要在defineProps的泛型中传入一组类型定义。若想为props声明初始值则需要在defineProps外包装一层withDefaults。",
      "setup中引入组件也同样简单，直接import后就可以将其当做组件名使用，如：",
      "当然， 在HbuilderX中的uni-app项目同样可以使用easycom方式加载组件，也就是在component目录下创建一个以组件名命名的目录，在其中放入对应的组件，就可以免去import直接引用：",
      "当我们尝试从父组件用ref的方式访问子组件内部方法或数据时，有如下几点是和v2不同的：",
      "访问方式不同",
      "首先在父组件中给子组件添加ref属性，然后声明一个与ref同名的变量，该变量即为ref的引用：",
      "const zoTest = ref<InstanceType<typeof ZoTest> | null>(null); ",
      "ref中有一个较为复杂的泛型，它主要是表明了该变量的类型为子组件暴露属性的类型或null。当DOM尚未渲染（或被v-if隐藏）时该变量的值可能为null。换言之，与v2相似的是，你依然要保证在DOM渲染完成后再去尝试访问ref内部的属性。至于暴露属性这个概念，见下一条。",
      "子组件需要声明向外部暴露的属性",
      "在v3的script setup中，子组件的属性默认无法通过ref直接访问到。我们可以使用defineExpose宏来手动声明该组件允许向外部暴露的属性列表。在上述代码示例中，我们只暴露了onButtonClick方法。",
      "在v3中新增了很多钩子。常用的有watchEffect()、watch()、computed()。",
      "computed()的使用方法和v2基本一致，只是函数化了。例如，我们想要为props中的color属性绑定一个计算属性：",
      "watchEffect钩子的作用是立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。换言之，watchEffect内部的任何一项依赖改变都会触发它，回调函数的触发就是因为依赖改变而导致的副作用。",
      "第一个参数就是要运行的副作用函数。这个副作用函数的参数也是一个函数，用来注册清理回调。清理回调会在该副作用下一次执行前被调用，可以用来清理无效的副作用，例如等待中的异步请求。",
      "第二个参数是一个可选的选项，可以用来调整副作用的刷新时机或调试副作用的依赖。",
      "返回值是一个用来停止该副作用的函数。",
      "在上述代码的例子中：",
      "我们监听了props.color，当它不是红色时持续监听，只要改变了就在控制台里打印一次。而当它变为红色时，销毁该副作用监听。",
      "watch钩子也是和v2基本一致的，三个参数分别为source、callback和options。",
      "第一个参数是监听器的源，这个来源可以是以下几种：",
      "第二个参数是在发生变化时要调用的回调函数。这个回调函数接受三个参数：新值、旧值，以及一个用于注册副作用清理的回调函数。该回调函数会在副作用下一次重新执行前调用，可以用来清除无效的副作用，例如等待中的异步请求。",
      "当侦听多个来源时，回调函数接受两个数组，分别对应来源数组中的新值和旧值。",
      "第三个可选的参数是一个对象，支持以下这些选项：",
      "与 watchEffect() 相比，watch() 使我们可以：",
      "在上述代码例子中：",
      "我们监听了eventRecorder的count属性，并在count被修改时执行对应的回调操作。",
      "在script setup中使用组件的高级用法",
      "动态组件、递归组件、命名空间组件请参阅使用组件",
      "插槽",
      "在v3中，具名插槽的使用方法变成了v-slot:header"
    ]
  },
  {
    "name": "从Vue到React 18系列 - 1.起步.md",
    "updateTime": "2023-04-12T09:24:04.287Z",
    "title": "从Vue到React 18系列 - 1.起步",
    "id": 13,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "local",
    "abstract": "以Vue2为主要参考对比，辅以部分Vue3概念，向React 18迁移的CookBook...",
    "heads": [
      "以Vue2为主要参考对比，辅以部分Vue3概念，向React 18迁移的CookBook",
      "创建Vite-React工程",
      "用点新东西吧。",
      "配置vite.config.ts",
      "在tsconfig.json的complierOptions下增加节点",
      "npm和yarn的区别",
      "命令对照",
      "起步：简单的Hello World",
      "App.tsx",
      "Mustache模板与JSX",
      "不同于Vue中常见的模板语法，React使用JSX语法来描述DOM元素。",
      "JSX在react中实质上只是React.createElement的语法糖。与Vue template相同的是，render函数返回的JSX有且只能有一个根节点。",
      "想直接返回多个子元素？试试<React.Fragment>",
      "在Vue模板中，我们使用形如{{ 表达式 }}的Mustache语法以在模板中取得Vue实例中的响应式变量（或计算属性）；而在React JSX中则可以使用形如{ 表达式 }的语法来声明一个变量或vDOM。",
      "与Vue不同的是，我们可以直接以变量的形式声明一个DOM元素，然后在组件实例的Render函数中以{}来引用。比如上述的App.tsx实例代码，实际上会输出一行以h1标签包裹的字符串、一行以p标签包裹的相同字符串以及一个绑定了clickEvent事件的按钮。",
      "在使用Vue的模板语法时，我们通常利用v-bind指令（或它的语法糖冒号:）用来给DOM元素（或组件）传递一个动态值而非字符串字面量。如：",
      "而在React中应该使用{}代替\"\"书写：",
      "上述对比示例中，按钮拥有几个属性",
      "React函数式组件的return()和类组件中的render()都不能直接修改组件的状态（states及props）。",
      "在React中父组件更新子组件的props，在子组件接收到新的props时会通过componentWillReceiveProps()生命周期来执行this.setState()来更新视图，但不会引起第二次渲染。",
      "onClick等事件的小坑",
      "如果有这样一个组件：",
      "这个组件将会在渲染的时候首先打印\"错误用法\"，而后才会在点击按钮的时候打印\"hello\"，并且第一个按钮点击无反应。原因是组件渲染时直接将shout()当做一个函数执行了，而它返回了undefined，点击时实际上是onClick=undefined。",
      "如果为shout增加返回值，比如return \"哼哼哼\"，那么\"错误的\"按钮将会导致页面报错。因为此时onClick=\"哼哼哼\"，不是一个函数。",
      "为什么\"一针见血的\"按钮就可以正常使用呢？因为它实际上就是onClick=()=>{}，onClick执行函数当然没问题。同理，如果写onClick={showNow()}就不行了。",
      "当然，也可以进行柯里化："
    ]
  },
  {
    "name": "从Vue到React 18系列 - 2.组件的基本知识.md",
    "updateTime": "2023-04-12T09:54:50.847Z",
    "title": "从Vue到React 18系列 - 2.组件的基本知识",
    "id": 14,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "local",
    "abstract": "以Vue2为主要参考对比，辅以部分Vue3概念，向React 18迁移的CookBook...",
    "heads": [
      "以Vue2为主要参考对比，辅以部分Vue3概念，向React 18迁移的CookBook",
      "React类组件/Vue Options组件",
      "上述示例中均以函数式组件为示例。但是在学习React的过程中，类组件依然是一个绕不开的话题。React的类组件之于函数式组件就类似Vue3中的script\nsetup之于Vue2的选项式API。",
      "来自React官方文档的Clock组件：Clock.jsx",
      "用Vue Options Api改写：Clock.vue",
      "简单地来说，React类组件中的state大概相当于Vue2中的data()\n，state是属于当前组件私有的数据。以上述代码为例，在Vue中，若要使响应式数据的变化反馈到模板上，我们只需要为this.date赋新值即可；但在React中需要使用this.setState()\n方法进行赋值操作。直接向state赋值是无法重新渲染组件的，如：",
      "关于setState（或useStates）的更多信息，参见第6节：深入组件",
      "生命周期对比",
      "详细的React生命周期图",
      "类组件的事件绑定",
      "React在JSX中传递的事件不是一个字符串，而是一个函数。比如在onClick中，它所绑定的函数会丢失this指向，所以要记得使用箭头函数或通过手动bind来将事件处理函数的this一直指向当前实例化对象。常见的绑定方式有三种：",
      "函数式组件的事件绑定",
      "参见onClick等事件的小坑",
      "React函数式组件/Vue Composition组件",
      "Function Component 是更彻底的状态驱动抽象，甚至没有 Class Component 生命周期的概念，只有一个状态，而 React 负责同步到\nDOM。",
      "写法",
      "总的来说，Vue Compotision的写法很像React函数式组件。以<script setup>写法举例：",
      "下面是React函数式组件写法：",
      "在函数式组件中要使用useState hook进行state的声明和修改。useState的参数即为该state的初始值，使用数组解构可以得到一个访问state的引用以及用于更新该state的函数。在Vue\nComposition中，以ref()声明的响应式变量需要使用.value进行访问及更新，而React中的useState则是使用解构出的引用及更新函数分别进行访问/更新。",
      "从生命周期钩子迁移到useEffect()",
      "在Composition Api中访问生命周期可以使用形如onMounted(()=>{})\n的钩子，而在函数式组件中则可以使用useEffect这个较为通用的hook。",
      "useEffect的简单使用可以看下面的例子。若要进一步了解，参见精读《useEffect完全指南》",
      "第二个参数不传",
      "当useEffect第二个参数不传时，页面初始和数据更新\n的时候，第一个参数函数都会执行，所以此时初始页面时会输出一次哈哈哈哈\n，然后无论你点修改num或者修改count的按钮时，也都会输出哈哈哈哈",
      "第二个参数传空数组",
      "当useEffect第二个参数传[]时，那么第一个参数函数只有在页面初始的时候才会执行，也就是只执行一次，无论你点修改num或者修改count的按钮，都不会执行这个函数",
      "第二个参数传非空数组",
      "当useEffect第二个参数传非空数组时，页面初始和依赖的数据发生更新的时候，第一个参数函数都会执行。比如上方例子：",
      "return清除操作",
      "React 会在组件卸载的时候执行清除操作。effect 在每次渲染的时候都会执行。React 会在执行当前 effect 之前对上一个 effect 进行清除。",
      "一些组件的相关知识",
      "尽管上文中已经介绍过部分要点，不过还是有必要再总结一遍：",
      "注册及使用组件",
      "React组件没有全局注册和局部注册的概念，我们可以使用ES6的class或function来创建组件，调用通过import导入组件实例。",
      "类组件：",
      "函数式组件：",
      "在父组件中使用：",
      "组件的生命周期（八股文限定版）",
      "还别说，除开constructor真的有八种",
      "重要的事要强调：详细的React生命周期图",
      "constructor（调用React.Component的构造器，进行state的初始化及绑定事件处理方法等工作）",
      "componentWillMount（类似beforeMounted，在这里调用this.setState不会引起组件的重新渲染）",
      "render：根据props和state返回一个React Element。在这里不能调用this.setState，否则会改变组件的状态",
      "componentDidMount：组件挂载到DOM后调用。此时已经可以获取到DOM，类似于Mounted。在这里调用this.setState也会引起组件的重新渲染。",
      "componentWillReceiveProps(newProps)\n：父组件传给该组件新的props时触发的钩子，一般需要比较新props与this.props来决定是否执行props变化后的逻辑，例如根据新props调用this.setState触发重新渲染。",
      "shouldComponentUpdate(newProps, newState)\n：该方法决定组件是否继续更新。一般通过比较新props、state与组件当前的props、state来决定该方法返回true还是false，从而减少组件不必要的渲染，优化性能。",
      "componentWillUpdate(newProps, newState)：该方法在render调用前执行。",
      "componentDidUpdate(oldProps, oldState)：组件更新后的钩子，可以在此处操作更新后的DOM",
      "componentWillUnmount：卸载组件前调用，类似于beforeDestory。",
      "类组件、函数式组件的一些区别",
      "若要学习更多，参见[20. 从类组件迁移到函数式组件](##20. 从类组件迁移到函数式组件)",
      "函数组件相比较类组件，优点是更轻量与灵活，便于逻辑的拆分复用。",
      "类组件、函数式组件在TypeScript中",
      "函数式组件React.FC<>",
      "React.FC是函数式组件，是在TypeScript使用的一个泛型，FC就是FunctionComponent的缩写，事实上React.FC可以写成React.FunctionComponent：",
      "React.FC 包含了 PropsWithChildren 的泛型，不用显式的声明 props.children 的类型。React.FC<>\n对于返回类型是显式的，而普通函数版本是隐式的（否则需要附加注释）注意，React 18与低版本在此处有所不同，参见下文",
      "React.FC提供了类型检查和自动完成的静态属性：displayName，propTypes和defaultProps（注意：defaultProps与React.FC结合使用会存在一些问题）。",
      "使用React.FC来写 React 组件的时候，是不能用setState的，取而代之的是useState()、useEffect等 Hook API。",
      "React 18和低版本的FC定义区别",
      "React 18不再预定义PropsWithChildren",
      "React < 18则有",
      "类组件class xx extends React.Component",
      "定义组件的Props属性及默认值（参数类型检查）",
      "使用TypeScript的类型检查",
      "使用JavaScript的类型检查",
      "可以不要开历史的倒车吗？还要记得安装一个库npm install prop-types --save",
      "更多用法，如声明联合类型、检查对象由特定的类型值组成等请参考使用PropTypes类型检查",
      "使用state的一些要点",
      "如果尝试使用setState()更新的数据依赖于this.props或this.state，那么应该向setState()传入一个函数而非一个对象，因为React\n可能会把多个 setState()调用合并成一个调用，而this.props 和 this.state 可能会异步更新。",
      "简而言之，第二次更新state时的逻辑如果是基于上一次的state，如state.counter += 1，那么它可能不会得到你预期中的值。",
      "这个函数用上一个 state 作为第一个参数，将此次更新被应用时的 props 做为第二个参数：",
      "阅读官网的setState函数有助于理解它与Vue的响应式数据修改的区别。",
      "setState()有两个参数，分别是上述的updater函数以及可选的callback函数。如：",
      "每次时间更新后都会调用一次console.log(114)。",
      "类似于Vue2中操作响应式对象或数组时需要注意的点",
      "在修改state中的引用对象或数组时需要先进行浅拷贝再修改。",
      ""
    ]
  },
  {
    "name": "从Vue到React 18系列 - 3.组件的用法迁移.md",
    "updateTime": "2023-04-12T09:24:04.292Z",
    "title": "从Vue到React 18系列 - 3.组件的用法迁移",
    "id": 15,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "local",
    "abstract": "以Vue2为主要参考对比，辅以部分Vue3概念，向React 18迁移的CookBook...",
    "heads": [
      "以Vue2为主要参考对比，辅以部分Vue3概念，向React 18迁移的CookBook",
      "React中的父子组件通信、自定义事件、事件处理",
      "父子组件通信",
      "父传子",
      "1、使用props传递属性",
      "2、使用ref",
      "父组件通过React.createRef()创建Ref，保存在实例属性myRef上。父组件中，渲染子组件时，定义一个Ref属性，值为刚创建的myRef。",
      "父组件调用子组件的myFunc函数，传递一个参数，子组件接收到参数，打印出参数。",
      "参数从父组件传递给子组件，完成了父组件向子组件通信。",
      "子传父",
      "1、使用回调函数，参见下文自定义事件",
      "2、事件冒泡",
      "点击子组件的button按钮，事件会冒泡到父组件身上，触发父组件的onClick函数，打印出Jack。点击的是子组件，父组件执行函数，完成了子组件向父组件通信。",
      "自定义事件",
      "在Vue中，我们通常会声明一组v-on与emit来进行自定义事件的传递。而在React中则可以通过props将事件处理器本身传递进子组件中用以调用。",
      "Vue示例：",
      "React示例",
      "事件处理",
      "详解参见React的事件处理",
      "React中的祖孙组件通信：Provider-Consumer",
      "当组件嵌套层级过多时，使用props一层层地传递事件不是一个好主意。除了使用第三方状态库以外，还可以使用Provider-Consumer设计模式来解决这个问题。在Vue中，类似的模式是Provide-Inject。",
      "相关阅读：React组件设计模式-Provider-Consumer",
      "类组件示例",
      "函数式组件示例（使用hooks）",
      "实战：在文章分类页面中自定义筛选器",
      "预期效果：Categories.tsx页面传入文章分类，点击筛选器的具体文章类别时可以动态修改Categories.tsx中的参数",
      "文件结构：",
      "views/Categories.tsx",
      "components/CategoryList/Context.tsx",
      "components/CategoryList/CategoryList.tsx",
      "components/CategoryList/CategoryListItem.tsx",
      "在React组件中实现插槽",
      "向组件的props里传一个DOM进去就可以了，这里是JSX！",
      "在Vue中，我们可以像这样通过插槽来实现在自定义组件ComponentA中插入组件ComponentB：",
      "而在React中有一个props.children的概念，被父子件所包裹的子组件可以使用这个属性来获取。",
      "扩展阅读：React组件设计模式-组合组件",
      ""
    ]
  },
  {
    "name": "从Vue到React 18系列 - 4.Vue常用函数及用法的迁移.md",
    "updateTime": "2023-04-12T09:54:50.851Z",
    "title": "从Vue到React 18系列 - 4.Vue常用函数及用法的迁移",
    "id": 16,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "local",
    "abstract": "以Vue2为主要参考对比，辅以部分Vue3概念，向React 18迁移的CookBook...",
    "heads": [
      "以Vue2为主要参考对比，辅以部分Vue3概念，向React 18迁移的CookBook",
      "在React中实现Computed、Watch",
      "实现Watch",
      "类组件中通过componentDidUpdate访问变化前的props和states",
      "函数式组件中写个Hook就好。",
      "useWatch.js",
      "组件中使用：",
      "实现Computed",
      "类组件还是在componentDidUpdate里操作，都是一回事。当然，使用get收集依赖也行：",
      "函数式组件用useMemo这个hook：",
      "从v-if、v-show、v-model迁移",
      "在Vue中，v-if的本质是控制组件/DOM的渲染，而v-show只是控制它的display属性是否为none。所以在React中想要实现类似逻辑，只需要在render时使用三目运算符决定是否返回该DOM即可。",
      "如果想通过props传递控制组件来实现类似于v-if/v-show的效果，则需要在render时判断props内的相关属性并填充相关逻辑。",
      "以React写法来实现v-if的效果更是简单：",
      "v-model本质上是利用名为value的prop和名为input的事件来实现数据的双向绑定。",
      "从v-for、v-on:event迁移",
      "v-for",
      "React里直接使用map在JSX中进行循环即可。当然，如果想要用for，也可以尝试在JSX中插入一段立即执行的匿名函数。",
      "Vue示例：",
      "React示例：",
      "使用立即执行函数：",
      "v-on",
      "参见上节中的: React中的父子组件通信、自定义事件、事件处理",
      "React中的CSS方案",
      "内联样式",
      "优点：官方推荐，直接使用CSS Property Class描述样式；组件私有的样式不会导致冲突；可以动态获取当前state中的状态",
      "缺点：写法上都需要使用驼峰标识；会导致代码混乱；某些样式无法编写(比如伪类/伪元素)",
      "使用第三方库实现style scoped",
      "使用起来最接近于Vue中<style scoped>的实现：react-scoped-css",
      "导入外部CSS文件",
      "优点：写法和普通HTML开发相似，易于理解。",
      "缺点：导入的CSS是全局样式，可能导致冲突。",
      "CSS Modules",
      "优点：实现原理类似于<style scoped>，属于组件私有样式；",
      "缺点：",
      "引用的类名不能使用连接符(如 .header-title )，因为JS中不识别。尽管loader可以转换驼峰和连接符，但这将会出现如下情况：",
      "这将会产生一些理解成本，而且可能因粗心而导致一些意料之外的问题。",
      "动态修改样式时依然需要依赖于内联样式。",
      "以xxx.module.css（或.scss / .less等等）命名的样式文件在被组件导入后会被加载为一个CSS Module。",
      "示例：",
      "Vite配置CSS Modules",
      "详细说明参见Vite CSS",
      "首先安装一个喜欢的CSS预处理器",
      "然后配置vite.config.ts，使其支持驼峰转换：",
      "VSCode配置CSS Modules提示",
      "配置tsconfig.json",
      "配置VSCode settings.json",
      "CSS in JS",
      "该节部分via：React中的CSS",
      "实际上，官方文档也有提到过CSS in JS这种方案：",
      "在传统的前端开发中，我们通常会将结构（HTML）、样式（CSS）、逻辑（JavaScript）进行分离。",
      "当然，这种开发的方式也受到了很多的批评：",
      "批评声音虽然有，但是在我们看来很多优秀的CSS-in-JS的库依然非常强大、方便：",
      "目前比较流行的CSS-in-JS的库有哪些呢？",
      "styled-components目前是社区最流行的CSS-in-JS库，但这里推荐使用emotion。它拥有相当全面的功能，体积小巧，而且还是为数不多的支持source-map的css-in-js框架之一。Emotion文档",
      "Vite配置Emotion && Typescript支持",
      "配置vite.config.ts",
      "配置tsconfig.json",
      "新建.babelrc",
      "示例："
    ]
  },
  {
    "name": "从Vue到React 18系列 - 5.Vue全家桶的迁移.md",
    "updateTime": "2023-04-12T09:24:04.253Z",
    "title": "从Vue到React 18系列 - 5.Vue全家桶的迁移",
    "id": 17,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "local",
    "abstract": "以Vue2为主要参考对比，辅以部分Vue3概念，向React 18迁移的CookBook...",
    "heads": [
      "以Vue2为主要参考对比，辅以部分Vue3概念，向React 18迁移的CookBook",
      "路由管理：从Vue-Router到React-Router",
      "在本文编写时，React-Router实为React-Router-Dom V6，Vue-Router为Vue-Router V4（为了易于接受，文中大部分例子使用V3举例说明，V4的例子会特别标注出）。下文简称“React中”及“Vue中”。",
      "部分参考自React-Router-Dom6 最佳实践、React-router 路由的使用及配置、React-Router官方文档（写的不容易懂）、React-Router官方文档Examples、vue-router和react-router使用的异同点",
      "首先安装依赖",
      "Hash模式与History模式",
      "无论是React中还是Vue中，路由的实现模式都基于这两种模式。",
      "Hash模式",
      "它的实现原理主要是基于window.onhashchange事件：",
      "hash 模式下，发起的请求也不会被 hash 值影响（http请求中），不会重新加载页面。",
      "History模式",
      "它基于 window.onpopstate 事件：",
      "通过浏览器提供的 history api，url 更加好看了，但刷新时如果服务器中没有相应的资源就可能会报 404，这是因为刷新后又去请求了服务器。",
      "Vue若要切换路由模式需要在router.js（即路由声明文件）中修改，而React则是以不同组件包裹（类似于router-view，不过React版本的router-view自带了路由模式）来进行区分的。",
      "React Router Dom V6常用路由组件",
      "<router-link>与<Router>组件",
      "在Vue中我们可以使用router-link组件进行声明式路由跳转，如：",
      "而在React中则可以使用Link标签达到类似效果：",
      "Vue中router-link默认是a标签。若想替换成span标签，可使用<router-link tag='span'>。点击后默认会给该标签添加.router-link-active类，若要自定义链接激活时使用的css类名，可使用<router-link active-class=\"激活时的类名\">",
      "React中Link没有激活属性。若要使用激活属性可用NavLink替代：",
      "视图组件",
      "Vue中router-view会渲染出路径所匹配到的视图组件：",
      "React中Route组件负责匹配路由并渲染。<Route>在哪，组件就渲染在哪。",
      "Router组件有几个参数用法：",
      "path: 指定路由的跳转路径",
      "exact: 精确匹配路由",
      "component: 路由对应的组件",
      "render： 通过写render函数返回具体的dom",
      "render 也可以直接返回 About 组件",
      "使用render的好处是可以向组件传递自定义属性",
      "然后，就可在 About 组件中获取 props 和 name 属性：",
      "render 方法也可用来进行权限认证：",
      "location: 将与当前历史记录位置以外的位置相匹配，在路由过渡动效中很有用。",
      "sensitive: 区分路由大小写",
      "注意：如果路由 Route 外部包裹 Routes 时，路由匹配到对应的组件后，就不会继续渲染其他组件了。但是如果外部不包裹 Switch 时，所有路由组件会先渲染一遍，然后选择到匹配的路由进行显示。",
      "路由传参",
      "该部分Hooks使用方法参考【React Router v6】路由组件传参",
      "路径参数——动态路由匹配",
      "例子中的页面路径为http://localhost:5173/Detail/114/Yajuu",
      "URL Search Params",
      "例子中的页面路径为http://localhost:5173/Detail?age=24",
      "Component State Params",
      "参数不显示在URL中，类似Vue中的{ name, params }跳转方法",
      "React-Router-Dom V6 搭建博客框架实战",
      "文件结构",
      "实现目标",
      "首页默认加载views/Index.tsx，点击About可以离开该页面，显示单独的About.tsx页面；点击History可以携带路径参数跳转历史列表页面；点击Detail可以携带ID跳转文章详情页面。",
      "代码配置",
      "main.tsx",
      "App.tsx",
      "router/index.tsx",
      "Header.tsx",
      "MainBody.tsx",
      "views/About.tsx",
      "views/History.tsx",
      "views/Detail.tsx",
      "扩展：为博客管理后台使用路由守卫",
      "router/RouterGuard.tsx",
      "router/index.tsx",
      "App.tsx",
      "main.tsx",
      "状态管理：从VueX到MobX",
      "Vue官方推荐使用的状态管理工具是VueX，而在React中状态管理则有许多选择，比如Redux、MobX或Dva等；这里选择使用MobX作为入门介绍。",
      "安装",
      "yarn add mobx mobx-react",
      "配置",
      "router/AppState.ts",
      "router/index.tsx",
      "main.tsx",
      "在组件中使用",
      "views/Login.tsx"
    ]
  },
  {
    "name": "从Vue到React 18系列 - 6.深入组件.md",
    "updateTime": "2023-04-12T09:24:04.257Z",
    "title": "从Vue到React 18系列 - 6.深入组件",
    "id": 18,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "local",
    "abstract": "以Vue2为主要参考对比，辅以部分Vue3概念，向React 18迁移的CookBook...",
    "heads": [
      "以Vue2为主要参考对比，辅以部分Vue3概念，向React 18迁移的CookBook",
      "React Hook",
      "React Hook既强大又灵活，它在有状态的函数式组件中十分重要。由于本人学习React的时间很短，尚不敢打包票说自己对Hooks有如何深刻的了解，故在此分享一些读过的文章以作参考学习之用。",
      "React中使用异步组件（懒加载组件）",
      "参考官网文档React.lazy",
      "注意！你的组件必须是export default形式！否则会报类型转换错误！",
      "React和Vue中的Key、Diff",
      "为什么 React 的 Diff 算法不采用 Vue 的双端对比算法？",
      "Render的Capture Value特性",
      "本节参考精读《Function VS Class 组件》及精读《useEffect 完全指南》，部分内容有删改。",
      "每次 Render 都有自己的 Props 与 State",
      "可以认为每次 Render 的内容都会形成一个快照并保留下来，因此当状态变更而 Rerender 时，就形成了 N 个 Render 状态，而每个 Render 状态都拥有自己固定不变的 Props 与 State。",
      "看下面的 count：",
      "在每次点击时，count 只是一个不会变的常量，而且也不存在利用 Proxy 的双向绑定，只是一个常量存在于每次 Render 中。",
      "初始状态下 count 值为 0，而随着按钮被点击，在每次 Render 过程中，count 的值都会被固化为 1、2、3：",
      "其实不仅是对象，函数在每次渲染时也是独立的。这就是 Capture Value 特性。",
      "每次 Render 都有自己的事件处理",
      "解释了为什么下面的代码会输出 5 而不是 3:",
      "在 log 函数执行的那个 Render 过程里，temp 的值可以看作常量 5，执行 **setTemp(3)** 时会交由一个全新的 Render 渲染，所以不会执行 log 函数。而 3 秒后执行的内容是由 **temp** 为 **5** 的那个 Render 发出的，所以结果自然为 5。",
      "原因就是 temp、log 都拥有 Capture Value 特性。",
      "每次 Render 都有自己的 Effects",
      "useEffect 也一样具有 Capture Value 的特性。",
      "useEffect 在实际 DOM 渲染完毕后执行，那 useEffect 拿到的值也遵循 Capture Value 的特性：",
      "上面的 useEffect 在每次 Render 过程中，拿到的 count 都是固化下来的常量。",
      "如何绕过 Capture Value",
      "利用 useRef 就可以绕过 Capture Value 的特性。可以认为 **ref** 在所有 Render 过程中保持着唯一引用，因此所有对 **ref** 的赋值或取值，拿到的都只有一个最终状态，而不会在每个 Render 间存在隔离。",
      "也可以简洁的认为，ref 是 Mutable 的，而 state 是 Immutable 的。",
      "从类组件迁移到函数式组件",
      "本节参考精读《Function VS Class 组件》，部分内容有删改。",
      "怎么替代 shouldComponentUpdate",
      "说实话，Function Component 替代 shouldComponentUpdate 的方案并没有 Class Component 优雅，代码是这样的：",
      "或者在父级就直接生成一个自带 memo 的子元素：",
      "相比之下，Class Component 的写法通常是：",
      "这样就自带了 shallowEqual 的 shouldComponentUpdate。",
      "怎么替代 componentDidUpdate",
      "由于 useEffect 每次 Render 都会执行，因此需要模拟一个 useUpdate 函数：",
      "更多可以查看 精读《怎么用 React Hooks 造轮子》",
      "怎么替代 forceUpdate",
      "React 官方文档提供了一种方案：",
      "每次执行 dispatch 时，只要 state 变化就会触发组件更新。当然 useState 也同样可以模拟：",
      "我们知道 useState 下标为 1 的项是用来更新数据的，而且就算数据没有变化，调用了也会刷新组件，所以我们可以把返回一个没有修改数值的 setValue，这样它的功能就仅剩下刷新组件了。",
      "更多可以查看 精读《怎么用 React Hooks 造轮子》",
      "state 拆分过多",
      "useState 目前的一种实践，是将变量名打平，而非像 Class Component 一样写在一个 State 对象里：",
      "实际上在 Function Component 中也可以聚合管理 State：",
      "只是更新的时候，不再会自动 merge，而需要使用 ...state 语法：",
      "可以看到，更少的黑魔法，更可预期的结果。",
      "获取上一个 props",
      "虽然不怎么常用，但是毕竟 Class Component 可以通过 componentWillReceiveProps 拿到 previousProps 与 nextProps，对于 Function Component，最好通过自定义 Hooks 方式拿到上一个状态：",
      "通过 useEffect 在组件渲染完毕后再执行的特性，再利用 useRef 的可变特性，让 usePrevious 的返回值是 “上一次” Render 时的。",
      "可见，合理运用 useEffect useRef，可以做许多事情，而且封装成 CustomHook 后使用起来仍然很方便。",
      "未来 usePrevious 可能成为官方 Hooks 之一。",
      "性能注意事项",
      "useState 函数的参数虽然是初始值，但由于整个函数都是 Render，因此每次初始化都会被调用，如果初始值计算非常消耗时间，建议使用函数传入，这样只会执行一次：",
      "useRef 不支持这种特性，需要写一些冗余的函判定是否进行过初始化。",
      "掌握了这些，Function Component 使用起来与 Class Component 就几乎没有差别了！"
    ]
  },
  {
    "name": "代码规范1.0.md",
    "updateTime": "2023-04-12T09:56:25.352Z",
    "title": "代码规范1.0",
    "id": 19,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "",
    "abstract": "本文档结合了AirBnb代码规范及阿里代码规范制订而成。",
    "heads": [
      "概述",
      "本文档结合了AirBnb代码规范及阿里代码规范制订而成。",
      "通用",
      "公共部分",
      "项目命名",
      "全部采用小写方式， 以短横线分隔。例：my-project-name。",
      "目录命名",
      "参照项目命名规则，有复数结构时，要采用复数命名法，缩写不用复数。",
      "例：docs、assets、components、directives、mixins、utils、views等。",
      "例：scripts/styles/components/images/utils/layouts/demo-styles/demo-scripts/img/doc",
      "文件命名",
      "文件名称统一用小写的英文字母、数字和下划线的组合，其中不得包含汉字、空格和特殊字符。",
      "命名原则的指导思想是使得你自己和工作组的每一个成员能够方便的理解每一个文件的意义。尽可能地使用标准的英文翻译。不能出现拼写错误的情况。代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。注意，即使纯拼音命名方式也要避免采用。杜绝完全不规范的缩写，避免望文不知义。",
      "JS、CSS、SCSS、HTML、PNG 等文件：全部采用小写方式， 优先选择单个单词命名，多个单词命名以短横线分隔。如：date-picker.scss、normalize.less等。",
      "特殊的文件命名",
      "Vue.js",
      "单文件组件",
      "文件扩展名为 .vue 的 single-file components。单文件组件名应该始终是单词大写开头 (PascalCase)。组件名应该倾向于而不是缩写。 编辑器中的自动补全已经让书写长命名的代价非常低了，而其带来的明确性却是非常宝贵的。不常用的缩写尤其应该避免。组件名应该始终是多个单词组成（大于等于 2）。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。如：MyComponent.vue、StudentDashboardSettings.vue、UserProfileOptions.vue等。",
      "单例组件",
      "只拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性。",
      "这不意味着组件只可用于一个单页面，而是_每个页面_只使用一次。这些组件永远不接受任何 prop，因为它们是为你的应用定制的。如果你发现有必要添加 prop，那就表明这实际上是一个可复用的组件，_只是目前_在每个页面里只使用一次。",
      "比如，头部和侧边栏组件几乎在每个页面都会使用，不接受 prop，该组件是专门为该应用所定制的。如：TheHeader.vue、TheFooter.vue等。",
      "基础组件",
      "不包含业务，独立、具体功能的基础组件，比如日期选择器、模态框等，这类组件作为项目的基础控件，会被大量使用，因此组件的 API 进行过高强度的抽象，可以通过不同配置实现不同的功能。",
      "应用特定样式和约定的基础组件(也就是展示类的、无逻辑的或无状态、不掺杂业务逻辑的组件) 应该全部以一个特定的前缀开头 —— Base。基础组件在一个页面内可使用多次，在不同页面内也可复用，是高可复用组件。如：BaseButton.vue、BaseTable.vue等。",
      "业务组件",
      "业务组件：它不像基础组件只包含某个功能，而是在业务中被多个页面复用的（具有可复用性），它与基础组件的区别是，业务组件只在当前项目中会用到，不具有通用性，而且会包含一些业务，比如数据请求；而基础组件不含业务，在任何项目中都可以使用，功能单一，比如一个具有数据校验功能的输入框。",
      "掺杂了复杂业务的组件（拥有自身 data、prop 的相关处理）即业务组件应该以 Custom 前缀命名。业务组件在一个页面内比如：某个页面内有一个卡片列表，而样式和逻辑跟业务紧密相关的卡片就是业务组件。如：CustomCard.vue、CustomVisualizationTable.vue等。",
      "紧密耦合的组件",
      "和父组件紧密耦合的子组件应该以父组件名作为前缀命名。 因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。如：TodoList.vue、TodoListItem.vue、TodoListItemButton.vue等。",
      "组件名中单词顺序",
      "组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。 因为编辑器通常会按字母顺序组织文件，所以现在组件之间的重要关系一目了然。如下组件主要是用于搜索和设置功能。",
      "如：SearchButtonClear.vue、SearchButtonRun.vue、SearchInputQuery.vue、SearchInputExcludeGlob.vue等。",
      "注释",
      "遵循 JSDoc 标准注释",
      "页面文件头部：包括描述、作者、开发时间、使用的接口、接收到页面参数等，如：",
      "变量、常量都需要注释：包括类型、说明、枚举值等",
      "函数都需要注释：其中公用函数的注释应尽量详细，应包含描述、参数、返回、示例等",
      "调用接口的参数：都需要注释，包含说明、枚举值等",
      "待定事项使用@todo或// TODO",
      "HTML（含Vue Template）",
      "缩进：缩进使用 2 个空格（一个 tab），嵌套的节点应该缩进。",
      "分块注释：在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释。重要节点要补充注释。",
      "语义化标签：HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div 或者 p 标签。",
      "引号：使用双引号(\" \") 而不是单引号(’ ') 。",
      "正例：<div class=\"box\"></div>",
      "反例：<div class='box'></div>",
      "布尔值属性不设置值，如：",
      "结构顺序和视觉顺序基本保持一致：按照从上至下、从左到右的视觉顺序书写HTML结构；有时候为了便于搜索引擎抓取，我们也会将重要内容在HTML 结构顺序上提前。",
      "结构、表现、行为三者分离，避免内联：内联样式会增加渲染成本且难以维护。除非模板中样式需要 js 逻辑去控制，如通过 vue 的计算属性。",
      "避免使用元素 id：一般元素 id 只适合应用在框架中，如左边菜单树、头部导航栏。",
      "JavaScript",
      "通用",
      "命名",
      "采用小写驼峰命名 lowerCamelCase，代码中的命名均不能含有下划线， 也不能以下划线或美元符号结束。",
      "方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。",
      "正例： localValue / getHttpMessage() / inputUserId",
      "method 方法命名必须是 动词 或者 动词+名词 形式",
      "正例： saveShopCarData /openShopCarInfoDialog",
      "反例： save / open / show / go",
      "增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）:",
      "add / update / delete / detail / get ",
      "常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚， 不要嫌名字长\n正例：MAX_STOCK_COUNT",
      "反例： MAX_COUNT",
      "引用",
      "尽可能地使用 const来进行赋值，避免使用 var。",
      "如果一定要对参数重新赋值，使用 let，而不是 var。",
      "字符串",
      "统一使用单引号(‘)，不使用双引号(“)。这在创建 HTML 字符串非常有好处。",
      "正例：",
      "let str = 'foo';\nlet testDiv = '<div id=\"test\"></div>';",
      "对象",
      "使用字面值创建对象\n正例： let user = {};",
      "反例：let user = new Object();",
      "使用字面量来代替对象构造器\n正例： let user = { age: 0, name: 1, city: 3 };",
      "反例：",
      "使用 ES6+",
      "必须优先使用 ES6+ 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复 用。比如箭头函数、await/async ， 解构， let ， for…of 等等。",
      "这是常见的各种ES6特性：",
      "括号",
      "下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try,catch, finally, with。",
      "undefined 判断",
      "永远不要直接使用 undefined 进行变量判断；使用 typeof 和字符串’undefined’对变量进行判断。",
      "正例：if (typeof person === 'undefined') { ... }\n反例：if (person === undefined) { ... }",
      "条件判断和循环最多三层",
      "条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的 三目运算符。如果超过 3 层请抽成函数，并写清楚注释。",
      "this 的转换命名",
      "对上下文 this 的引用只能使用 self或_this 来命名。",
      "慎用 console.log",
      "因 console.log 大量使用会有性能问题，所以在非 webpack 项目中谨慎使用 log 功能。",
      "尽可能使用强等于（不等于）代替弱等于（不等于）",
      "绝对不要使用 eval！永远不要使用 Function 构造函数！永远不要将字符串传递给setTimeout 或 setInterval！",
      "Vue.js 2.x",
      "规范基础",
      "Vue 项目规范以 Vue 官方规范 （ https://v2.cn.vuejs.org/v2/style-guide/） 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。",
      "在 Template 模版中使用组件",
      "应使用 PascalCase 模式，并且使用自闭合组件。",
      "正例：",
      "反例：",
      "组件的 data 必须是一个函数",
      "当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。因为如果直接是一个对象的话，子组件之间的属性值会互相影响。",
      "Prop 定义应该尽量详细",
      "必须使用 camelCase 驼峰命名",
      "必须指定类型",
      "必须加上注释，表明其含义",
      "必须加上 required 或者 default，两者二选其一",
      "如果有业务需要，必须加上 validator 验证",
      "为组件样式设置作用域",
      "正例：",
      "反例：",
      "模板中使用简单的表达式",
      "组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。",
      "正例：",
      "反例：",
      "指令都使用缩写形式",
      "正例：",
      "反例：",
      "标签顺序保持一致",
      "单文件组件应该总是让标签顺序保持为template > script > style",
      "正例：",
      "反例：",
      "必须为 v-for 设置键值 key",
      "v-show 与 v-if 选择",
      "如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。",
      "script 标签内部结构顺序",
      "components > props > data > computed > watch > filter > 钩子函数（钩子函数按其执行顺序） > methods",
      "uni-app",
      "使用template元素而非block元素",
      "uni-app 支持在 template 模板中嵌套 template 和 block，用来进行 列表渲染 和 条件渲染。",
      "template 和 block 并不是一个组件，它们仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。",
      "block 在不同的平台表现存在一定差异，推荐统一使用 template。",
      "代码示例",
      "兼容app-nvue平台时使用flex布局",
      "CSS",
      "术语",
      "规则声明",
      "我们把一个（或一组）选择器和一组属性称之为 “规则声明”。举个例子：",
      "选择器",
      "在规则声明中，“选择器” 负责选取 DOM 树中的元素，这些元素将被定义的属性所修饰。选择器可以匹配 HTML 元素，也可以匹配一个元素的类名、ID, 或者元素拥有的属性。以下是选择器的例子：",
      "属性",
      "最后，属性决定了规则声明里被选择的元素将得到何种样式。属性以键值对形式存在，一个规则声明可以包含一或多个属性定义。以下是属性定义的例子：",
      "通用",
      "尽可能将所有 css 写在外部样式表中。",
      "不要在外部样式表里面利用@import 导入其他 css 文件。",
      "尽量避免使用 css 表达式。",
      "选择器的顺序应与元素保持一致。",
      "属性声明的顺序：遵循先布局后样式，特殊地，伪类元素的content 应放于最前面。",
      "参考顺序：定位→布局→盒子→尺寸→文本排版→视觉外观。",
      "定位：position（包括 top、right、bottom、left、z-index）、float、clear 等",
      "布局：display（包括 vertical-align、弹性布局的 flex-direction、align-items 等）、overflow等",
      "盒子：box-sizing、margin、padding、border 等",
      "尺寸：width、height、line-height 等",
      "文本排版：font、text-align、white-space 等",
      "视觉外观：transform、color、border-radius、transition、background等",
      "格式",
      "Bad",
      "Good",
      "注释",
      "OOCSS 和 BEM",
      "出于以下原因，我们鼓励使用 OOCSS 和 BEM 的某种组合：",
      "OOCSS，也就是 “Object Oriented CSS（面向对象的CSS）”，是一种写 CSS 的方法，其思想就是鼓励你把样式表看作“对象”的集合：创建可重用性、可重复性的代码段让你可以在整个网站中多次使用。",
      "参考资料：",
      "BEM，也就是 “Block-Element-Modifier”，是一种用于 HTML 和 CSS 类名的_命名约定_。BEM 最初是由 Yandex 提出的，要知道他们拥有巨大的代码库和可伸缩性，BEM 就是为此而生的，并且可以作为一套遵循 OOCSS 的参考指导规范。",
      "示例",
      "ID 选择器",
      "在 CSS 中，虽然可以通过 ID 选择元素，但大家通常都会把这种方式列为反面教材。ID 选择器给你的规则声明带来了不必要的高优先级，而且 ID 选择器是不可重用的。",
      "想要了解关于这个主题的更多内容，参见 CSS Wizardry 的文章，文章中有关于如何处理优先级的内容。",
      "JavaScript 钩子",
      "避免在 CSS 和 JavaScript 中绑定相同的类。否则开发者在重构时通常会出现以下情况：轻则浪费时间在对照查找每个要改变的类，重则因为害怕破坏功能而不敢作出更改。",
      "我们推荐在创建用于特定 JavaScript 的类名时，添加 .js- 前缀：",
      "边框",
      "在定义无边框样式时，使用 0 代替 none。",
      "Bad",
      "Good",
      "省略0后面的单位",
      "Bad",
      "Good",
      "尽量使用缩写属性",
      "Bad",
      "Good",
      "使用CSS预处理器（Scss/Sass/Less等）",
      "通用",
      "文件组织",
      "文件按以下顺序组织：",
      "避免嵌套层级过多",
      "请不要让嵌套选择器的深度超过 3 层！",
      "对于超过 4 级的嵌套，给予重新评估。这可以避免出现过于详实的 CSS 选择器。避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于 20 行的嵌套规则出现。",
      "当遇到以上情况的时候，你也许是这样写 CSS 的：",
      "再说一遍: 永远不要嵌套 ID 选择器！",
      "如果你始终坚持要使用 ID 选择器（劝你三思），那也不应该嵌套它们。如果你正打算这么做，你需要先重新检查你的标签，或者指明原因。如果你想要写出风格良好的 HTML 和 CSS，你是不应该这样做的。",
      "Scss/Sass",
      "语法",
      "属性声明的排序",
      "属性声明",
      "首先列出除去 @include 和嵌套选择器之外的所有属性声明。",
      "@include 声明",
      "紧随后面的是 @include，这样可以使得整个选择器的可读性更高。",
      "嵌套选择器",
      "_如果有必要_用到嵌套选择器，把它们放到最后，在规则声明和嵌套选择器之间要加上空白，相邻嵌套选择器之间也要加上空白。嵌套选择器中的内容也要遵循上述指引。",
      "变量",
      "变量名应使用破折号（例如 $my-variable）代替 camelCased 和 snake_cased 风格。对于仅用在当前文件的变量，可以在变量名之前添加下划线前缀（例如 $_my-variable）。",
      "Mixins",
      "为了让代码遵循 DRY 原则（Don't Repeat Yourself）、增强清晰性或抽象化复杂性，应该使用 mixin，这与那些命名良好的函数的作用是异曲同工的。虽然 mixin 可以不接收参数，但要注意，假如你不压缩负载（比如通过 gzip），这样会导致最终的样式包含不必要的代码重复。",
      "扩展指令",
      "应避免使用 @extend 指令，因为它并不直观，而且具有潜在风险，特别是用在嵌套选择器的时候。即便是在顶层占位符选择器使用扩展，如果选择器的顺序最终会改变，也可能会导致问题。（比如，如果它们存在于其他文件，而加载顺序发生了变化）。其实，使用 @extend 所获得的大部分优化效果，gzip 压缩已经帮助你做到了，因此你只需要通过 mixin 让样式表更符合 DRY 原则就足够了。",
      "Less",
      "同Scss（除Scss特殊指令名外）",
      "附录",
      "函数方法常用的动词："
    ]
  },
  {
    "name": "纯CSS实现横向树组件.md",
    "updateTime": "2023-04-12T09:24:04.309Z",
    "title": "纯CSS实现横向树组件",
    "id": 20,
    "isTop": false,
    "tags": [],
    "categories": [],
    "poster": "",
    "abstract": "...",
    "heads": [
      "CSS",
      "模板"
    ]
  }
]